import type { Cred } from './cred';
import { NoSyncFile } from './file';
import { FileSystem } from './filesystem';
import { Stats } from './stats';
/**
 * @internal
 */
export type ListingTree = {
    [key: string]: ListingTree | null;
};
/**
 * @internal
 */
export interface ListingQueueNode<T> {
    pwd: string;
    tree: ListingTree;
    parent: IndexDirInode<T>;
}
/**
 * A simple class for storing a filesystem index. Assumes that all paths passed
 * to it are *absolute* paths.
 *
 * Can be used as a partial or a full index, although care must be taken if used
 * for the former purpose, especially when directories are concerned.
 *
 * @internal
 */
export declare class FileIndex<T> {
  /**
     * Static method for constructing indices from a JSON listing.
     * @param listing Directory listing generated by tools
     * @return A new FileIndex object.
     */
  static FromListing<T>(listing: ListingTree): FileIndex<T>;
  protected _index: Map<string, IndexDirInode<T>>;
  /**
     * Constructs a new FileIndex.
     */
  constructor();
  files(): IndexFileInode<T>[];
  /**
     * Adds the given absolute path to the index if it is not already in the index.
     * Creates any needed parent directories.
     * @param path The path to add to the index.
     * @param inode The inode for the
     *   path to add.
     * @return 'True' if it was added or already exists, 'false' if there
     *   was an issue adding it (e.g. item in path is a file, item exists but is
     *   different).
     * @todo If adding fails and implicitly creates directories, we do not clean up
     *   the new empty directories.
     */
  add(path: string, inode: IndexInode<T>): boolean;
  /**
     * Adds the given absolute path to the index if it is not already in the index.
     * The path is added without special treatment (no joining of adjacent separators, etc).
     * Creates any needed parent directories.
     * @param path The path to add to the index.
     * @param inode The inode for the path to add.
     * @return 'True' if it was added or already exists, 'false' if there
     *   was an issue adding it (e.g. item in path is a file, item exists but is
     *   different).
     * @todo If adding fails and implicitly creates directories, we do not clean up the new empty directories.
     */
  addFast(path: string, inode: IndexInode<T>): boolean;
  /**
     * Removes the given path. Can be a file or a directory.
     * @return The removed item,
     *   or null if it did not exist.
     */
  remove(path: string): IndexInode<T> | null;
  /**
     * Retrieves the directory listing of the given path.
     * @return An array of files in the given path, or 'null' if it does not exist.
     */
  ls(path: string): string[] | null;
  /**
     * Returns the inode of the given item.
     * @return Returns null if the item does not exist.
     */
  get(path: string): IndexInode<T> | null;
}
/**
 * Generic interface for file/directory inodes.
 * Note that Stats objects are what we use for file inodes.
 */
export declare abstract class IndexInode<T> {
  data?: T;
  constructor(data?: T);
    /**
     * Whether this inode is for a file
     */
    abstract isFile(): this is IndexFileInode<T>;
    /**
     * Whether this inode is for a directory
     */
    abstract isDirectory(): this is IndexDirInode<T>;
    abstract toStats(): Stats;
}
/**
 * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.
 */
export declare class IndexFileInode<T> extends IndexInode<T> {
  isFile(): boolean;
  isDirectory(): boolean;
  toStats(): Stats;
}
/**
 * Inode for a directory. Currently only contains the directory listing.
 */
export declare class IndexDirInode<T> extends IndexInode<T> {
  /**
     * @internal
     */
  _listing: Map<string, IndexInode<T>>;
  isFile(): boolean;
  isDirectory(): boolean;
  /**
     * Return a Stats object for this inode.
     * @todo Should probably remove this at some point. This isn't the responsibility of the FileIndex.
     */
  get stats(): Stats;
  /**
     * Alias of getStats()
     * @todo Remove this at some point. This isn't the responsibility of the FileIndex.
     */
  toStats(): Stats;
  /**
     * Returns the directory listing for this directory. Paths in the directory are
     * relative to the directory's path.
     * @return The directory listing for this directory.
     */
  get listing(): string[];
  /**
     * Returns the inode for the indicated item, or null if it does not exist.
     * @param path Name of item in this directory.
     */
  get(path: string): IndexInode<T> | null;
  /**
     * Add the given item to the directory listing. Note that the given inode is
     * not copied, and will be mutated by the DirInode if it is a DirInode.
     * @param path Item name to add to the directory listing.
     * @param inode The inode for the
     *   item to add to the directory inode.
     * @return True if it was added, false if it already existed.
     */
  add(path: string, inode: IndexInode<T>): boolean;
  /**
     * Removes the given item from the directory listing.
     * @param p Name of item to remove from the directory listing.
     * @return Returns the item
     *   removed, or null if the item did not exist.
     */
  remove(p: string): IndexInode<T> | null;
}
declare const FileIndexFS_base: (abstract new (...args: any[]) => {
    metadata(): import('./filesystem').FileSystemMetadata;
    rename(oldPath: string, newPath: string, cred: Cred): Promise<void>;
    renameSync(oldPath: string, newPath: string, cred: Cred): void;
    createFile(path: string, flag: string, mode: number, cred: Cred): Promise<import('./file').File>;
    createFileSync(path: string, flag: string, mode: number, cred: Cred): import('./file').File;
    unlink(path: string, cred: Cred): Promise<void>;
    unlinkSync(path: string, cred: Cred): void;
    rmdir(path: string, cred: Cred): Promise<void>;
    rmdirSync(path: string, cred: Cred): void;
    mkdir(path: string, mode: number, cred: Cred): Promise<void>;
    mkdirSync(path: string, mode: number, cred: Cred): void;
    link(srcpath: string, dstpath: string, cred: Cred): Promise<void>;
    linkSync(srcpath: string, dstpath: string, cred: Cred): void;
    sync(path: string, data: Uint8Array, stats: Readonly<Stats>): Promise<void>;
    syncSync(path: string, data: Uint8Array, stats: Readonly<Stats>): void;
    ready(): Promise<any>;
    stat(path: string, cred: Cred): Promise<Stats>;
    statSync(path: string, cred: Cred): Stats;
    openFile(path: string, flag: string, cred: Cred): Promise<import('./file').File>;
    openFileSync(path: string, flag: string, cred: Cred): import('./file').File;
    readdir(path: string, cred: Cred): Promise<string[]>;
    readdirSync(path: string, cred: Cred): string[];
    exists(path: string, cred: Cred): Promise<boolean>;
    existsSync(path: string, cred: Cred): boolean;
}) & typeof FileSystem;
export declare abstract class FileIndexFS<TIndex> extends FileIndexFS_base {
  protected _index: FileIndex<TIndex>;
  constructor(index: ListingTree);
  stat(path: string): Promise<Stats>;
  statSync(path: string): Stats;
  openFile(path: string, flag: string, cred: Cred): Promise<NoSyncFile<this>>;
  openFileSync(path: string, flag: string, cred: Cred): NoSyncFile<this>;
  readdir(path: string): Promise<string[]>;
  readdirSync(path: string): string[];
    protected abstract statFileInode(inode: IndexFileInode<TIndex>, path: string): Promise<Stats>;
    protected abstract statFileInodeSync(inode: IndexFileInode<TIndex>, path: string): Stats;
    protected abstract openFileInode(inode: IndexFileInode<TIndex>, path: string, flag: string): Promise<NoSyncFile<this>>;
    protected abstract openFileInodeSync(inode: IndexFileInode<TIndex>, path: string, flag: string): NoSyncFile<this>;
}
export declare abstract class SyncFileIndexFS<TIndex> extends FileIndexFS<TIndex> {
  protected statFileInode(inode: IndexFileInode<TIndex>, path: string): Promise<Stats>;
  protected openFileInode(inode: IndexFileInode<TIndex>, path: string, flag: string): Promise<NoSyncFile<this>>;
}
declare const AsyncFileIndexFS_base: (abstract new (...args: any[]) => {
    _sync: FileSystem;
    metadata(): import('./filesystem').FileSystemMetadata;
    ready(): Promise<any>;
    renameSync(oldPath: string, newPath: string, cred: Cred): void;
    statSync(path: string, cred: Cred): Stats;
    createFileSync(path: string, flag: string, mode: number, cred: Cred): import('./file').File;
    openFileSync(path: string, flag: string, cred: Cred): import('./file').File;
    unlinkSync(path: string, cred: Cred): void;
    rmdirSync(path: string, cred: Cred): void;
    mkdirSync(path: string, mode: number, cred: Cred): void;
    readdirSync(path: string, cred: Cred): string[];
    linkSync(srcpath: string, dstpath: string, cred: Cred): void;
    syncSync(path: string, data: Uint8Array, stats: Readonly<Stats>): void;
    rename(oldPath: string, newPath: string, cred: Cred): Promise<void>;
    stat(path: string, cred: Cred): Promise<Stats>;
    openFile(path: string, flag: string, cred: Cred): Promise<import('./file').File>;
    createFile(path: string, flag: string, mode: number, cred: Cred): Promise<import('./file').File>;
    unlink(path: string, cred: Cred): Promise<void>;
    rmdir(path: string, cred: Cred): Promise<void>;
    mkdir(path: string, mode: number, cred: Cred): Promise<void>;
    readdir(path: string, cred: Cred): Promise<string[]>;
    exists(path: string, cred: Cred): Promise<boolean>;
    existsSync(path: string, cred: Cred): boolean;
    link(srcpath: string, dstpath: string, cred: Cred): Promise<void>;
    sync(path: string, data: Uint8Array, stats: Readonly<Stats>): Promise<void>;
}) & (abstract new (index: ListingTree) => FileIndexFS<unknown>);
export declare abstract class AsyncFileIndexFS<TIndex> extends AsyncFileIndexFS_base {
  _index: FileIndex<TIndex>;
  protected statFileInodeSync(): Stats;
  protected openFileInodeSync(): NoSyncFile<this>;
}
export {};
